{
  "address": "0xEd79CF5c0FD38CBb599f1A6E0DC7a68Ce2a3B2da",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "baseRatePerYear",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "oldAdjusterCoefficient",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newAdjusterCoefficient",
          "type": "uint256"
        }
      ],
      "name": "NewAdjusterCoefficient",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "oldBaseRateMantissa",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newBaseRateMantissa",
          "type": "uint256"
        }
      ],
      "name": "NewBaseRate",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "baserateperblock",
          "type": "uint256"
        }
      ],
      "name": "NewInterestParams",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "oldUpdateFrequency",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newUpdateFrequency",
          "type": "uint256"
        }
      ],
      "name": "NewUpdateFrequency",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "newAdjusterCoefficient",
          "type": "uint256"
        }
      ],
      "name": "_setAdjusterCoefficient",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "newBaseRateMantissa",
          "type": "uint256"
        }
      ],
      "name": "_setBaseRatePerYear",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "newUpdateFrequency",
          "type": "uint256"
        }
      ],
      "name": "_setUpdateFrequency",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "adjusterCoefficient",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "baseRatePerBlock",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "baseRatePerYear",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "blocksPerYear",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "cash",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "borrows",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "reserves",
          "type": "uint256"
        }
      ],
      "name": "getBorrowRate",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "cash",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "borrows",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "reserves",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "reserveFactorMantissa",
          "type": "uint256"
        }
      ],
      "name": "getSupplyRate",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isInterestRateModel",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lastUpdateBlock",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "note",
      "outputs": [
        {
          "internalType": "contract CToken",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "newBaseRatePerYear",
          "type": "uint256"
        }
      ],
      "name": "updateBaseRate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "updateFrequency",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x63d8e10c259e87cd9e44414cd62eb3f555b40d7767bece4dc962d35190d3f020",
  "receipt": {
    "to": null,
    "from": "0x6C25Da1943311392C191AAe71DCD41840C6D120D",
    "contractAddress": "0xEd79CF5c0FD38CBb599f1A6E0DC7a68Ce2a3B2da",
    "transactionIndex": 0,
    "gasUsed": "579115",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000004000008000000000000000100000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x8d56ee0611a78e855fff45a6679b9b127748e6b3e3ad9649623e19d5d62a5e31",
    "transactionHash": "0x63d8e10c259e87cd9e44414cd62eb3f555b40d7767bece4dc962d35190d3f020",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 121594,
        "transactionHash": "0x63d8e10c259e87cd9e44414cd62eb3f555b40d7767bece4dc962d35190d3f020",
        "address": "0xEd79CF5c0FD38CBb599f1A6E0DC7a68Ce2a3B2da",
        "topics": [
          "0x482980278ae2c1b5635532c44722d084a208f79b8f4212a3fc8e6042901552cb"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000000000016ae3c7f",
        "logIndex": 0,
        "blockHash": "0x8d56ee0611a78e855fff45a6679b9b127748e6b3e3ad9649623e19d5d62a5e31"
      }
    ],
    "blockNumber": 121594,
    "cumulativeGasUsed": "579115",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "2000000000000000"
  ],
  "numDeployments": 2,
  "solcInputHash": "73a3d52eabaed561aba3cf4e9e89e22e",
  "metadata": "{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"baseRatePerYear\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldAdjusterCoefficient\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAdjusterCoefficient\",\"type\":\"uint256\"}],\"name\":\"NewAdjusterCoefficient\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldBaseRateMantissa\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBaseRateMantissa\",\"type\":\"uint256\"}],\"name\":\"NewBaseRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baserateperblock\",\"type\":\"uint256\"}],\"name\":\"NewInterestParams\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldUpdateFrequency\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newUpdateFrequency\",\"type\":\"uint256\"}],\"name\":\"NewUpdateFrequency\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAdjusterCoefficient\",\"type\":\"uint256\"}],\"name\":\"_setAdjusterCoefficient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBaseRateMantissa\",\"type\":\"uint256\"}],\"name\":\"_setBaseRatePerYear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newUpdateFrequency\",\"type\":\"uint256\"}],\"name\":\"_setUpdateFrequency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adjusterCoefficient\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseRatePerYear\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blocksPerYear\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrows\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserves\",\"type\":\"uint256\"}],\"name\":\"getBorrowRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrows\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveFactorMantissa\",\"type\":\"uint256\"}],\"name\":\"getSupplyRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInterestRateModel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdateBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"note\",\"outputs\":[{\"internalType\":\"contract CToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBaseRatePerYear\",\"type\":\"uint256\"}],\"name\":\"updateBaseRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateFrequency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"canto\",\"kind\":\"dev\",\"methods\":{\"_setAdjusterCoefficient(uint256)\":{\"details\":\"Admin function to set per-market adjuster coefficient\",\"params\":{\"newAdjusterCoefficient\":\"The new adjuster coefficient, scaled by 1e18\"}},\"_setBaseRatePerYear(uint256)\":{\"details\":\"Admin function to set per-market base interest rate\",\"params\":{\"newBaseRateMantissa\":\"The new base interest rate, scaled by 1e18\"}},\"_setUpdateFrequency(uint256)\":{\"details\":\"Admin function to set the update frequency\",\"params\":{\"newUpdateFrequency\":\"The new update frequency, scaled by 1e18\"}},\"constructor\":{\"params\":{\"baseRatePerYear\":\"The approximate target base APR, as a mantissa (scaled by 1e18), set by admin, default 2%\"}},\"getBorrowRate(uint256,uint256,uint256)\":{\"returns\":{\"_0\":\"Note's borrow rate percentage per block as a mantissa (scaled by 1e18)\"}},\"getSupplyRate(uint256,uint256,uint256,uint256)\":{\"returns\":{\"_0\":\"Note's supply rate percentage per block as a mantissa (scaled by 1e18)\"}},\"updateBaseRate(uint256)\":{\"params\":{\"newBaseRatePerYear\":\"The new base rate per year of Note\"}}},\"title\":\"note's interest rate model contract\",\"version\":1},\"userdoc\":{\"events\":{\"NewAdjusterCoefficient(uint256,uint256)\":{\"notice\":\"Emitted when adjuster coefficient is changed by admin\"},\"NewBaseRate(uint256,uint256)\":{\"notice\":\"Emitted when base rate is changed by admin\"},\"NewUpdateFrequency(uint256,uint256)\":{\"notice\":\"Emitted when update frequency is changed by admin\"}},\"kind\":\"user\",\"methods\":{\"_setAdjusterCoefficient(uint256)\":{\"notice\":\"Sets the adjuster coefficient for Note\"},\"_setBaseRatePerYear(uint256)\":{\"notice\":\"Sets the base interest rate for Note\"},\"_setUpdateFrequency(uint256)\":{\"notice\":\"Sets the update frequency for Note's interest rate\"},\"adjusterCoefficient()\":{\"notice\":\"The level of aggressiveness to adjust interest rate according to twap's deviation from the peg\"},\"baseRatePerBlock()\":{\"notice\":\"baseRatePerBlock The per block interest rate, as a mantissa (scaled by 1e18)\"},\"baseRatePerYear()\":{\"notice\":\"baseRatePerYear The per year interest rate, as a mantissa (scaled by 1e18)\"},\"blocksPerYear()\":{\"notice\":\"The approximate number of blocks per year that is assumed by the interest rate model\"},\"constructor\":{\"notice\":\"Construct an interest rate model\"},\"getBorrowRate(uint256,uint256,uint256)\":{\"notice\":\"Calculates the current borrow rate per block, with the error code expected by the marketThe following parameters are irrelevent for calculating Note's interest rate. They are passed in to align with the standard function definition `getBorrowRate` in InterestRateModel\"},\"getSupplyRate(uint256,uint256,uint256,uint256)\":{\"notice\":\"Calculates the current supply rate per block, which is the same as the borrow rateThe following parameters are irrelevent for calculating Note's interest rate. They are passed in to align with the standard function definition `getSupplyRate` in InterestRateModel\"},\"isInterestRateModel()\":{\"notice\":\"Indicator that this is an InterestRateModel contract (for inspection)\"},\"lastUpdateBlock()\":{\"notice\":\"The variable to keep track of the last update on Note's interest rate, initialized at the current block number\"},\"note()\":{\"notice\":\"The CToken identifier for Note\"},\"updateBaseRate(uint256)\":{\"notice\":\"Updates the Note's base rate per year at a given intervalThis function should be called at a given interval (TBD)\"},\"updateFrequency()\":{\"notice\":\"The frequency of updating Note's base rate\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/NoteInterest.sol\":\"NoteRateModel\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/CErc20.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./CToken.sol\\\";\\n\\ninterface CompLike {\\n    function delegate(address delegatee) external;\\n}\\n\\n/**\\n * @title Compound's CErc20 Contract\\n * @notice CTokens which wrap an EIP-20 underlying\\n * @author Compound\\n */\\ncontract CErc20 is CToken, CErc20Interface {\\n    /**\\n     * @notice Initialize the new money market\\n     * @param underlying_ The address of the underlying asset\\n     * @param comptroller_ The address of the Comptroller\\n     * @param interestRateModel_ The address of the interest rate model\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n     * @param name_ ERC-20 name of this token\\n     * @param symbol_ ERC-20 symbol of this token\\n     * @param decimals_ ERC-20 decimal precision of this token\\n     */\\n    function initialize(address underlying_,\\n                        ComptrollerInterface comptroller_,\\n                        InterestRateModel interestRateModel_,\\n                        uint initialExchangeRateMantissa_,\\n                        string memory name_,\\n                        string memory symbol_,\\n                        uint8 decimals_) public {\\n        // CToken initialize does the bulk of the work\\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\\n\\n        // Set underlying and sanity check it\\n        underlying = underlying_;\\n        EIP20Interface(underlying).totalSupply();\\n    }\\n\\n    /*** User Interface ***/\\n\\n    /**\\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param mintAmount The amount of the underlying asset to supply\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function mint(uint mintAmount) override external returns (uint) {\\n        mintInternal(mintAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for the underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemTokens The number of cTokens to redeem into underlying\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeem(uint redeemTokens) override external returns (uint) {\\n        redeemInternal(redeemTokens);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemAmount The amount of underlying to redeem\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function redeemUnderlying(uint redeemAmount) override external returns (uint) {\\n        redeemUnderlyingInternal(redeemAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n      * @notice Sender borrows assets from the protocol to their own address\\n      * @param borrowAmount The amount of the underlying asset to borrow\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function borrow(uint borrowAmount) override external returns (uint) {\\n        borrowInternal(borrowAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender repays their own borrow\\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function repayBorrow(uint repayAmount) override external returns (uint) {\\n        repayBorrowInternal(repayAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender repays a borrow belonging to borrower\\n     * @param borrower the account with the debt being payed off\\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function repayBorrowBehalf(address borrower, uint repayAmount) override external returns (uint) {\\n        repayBorrowBehalfInternal(borrower, repayAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice The sender liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param borrower The borrower of this cToken to be liquidated\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) override external returns (uint) {\\n        liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\\n     * @param token The address of the ERC-20 token to sweep\\n     */\\n    function sweepToken(EIP20NonStandardInterface token) override external {\\n        require(msg.sender == admin, \\\"CErc20::sweepToken: only admin can sweep tokens\\\");\\n        require(address(token) != underlying, \\\"CErc20::sweepToken: can not sweep underlying token\\\");\\n        uint256 balance = token.balanceOf(address(this));\\n        token.transfer(admin, balance);\\n    }\\n\\n    /**\\n     * @notice The sender adds to reserves.\\n     * @param addAmount The amount fo underlying token to add as reserves\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _addReserves(uint addAmount) override external returns (uint) {\\n        return _addReservesInternal(addAmount);\\n    }\\n\\n    /*** Safe Token ***/\\n\\n    /**\\n     * @notice Gets balance of this contract in terms of the underlying\\n     * @dev This excludes the value of the current message, if any\\n     * @return The quantity of underlying tokens owned by this contract\\n     */\\n    function getCashPrior() virtual override internal view returns (uint) {\\n        EIP20Interface token = EIP20Interface(underlying);\\n        return token.balanceOf(address(this));\\n    }\\n\\n    /**\\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\\n     *      This will revert due to insufficient balance or insufficient allowance.\\n     *      This function returns the actual amount received,\\n     *      which may be less than `amount` if there is a fee attached to the transfer.\\n     *\\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n     */\\n    function doTransferIn(address from, uint amount) virtual override internal returns (uint) {\\n        // Read from storage once\\n        address underlying_ = underlying;\\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying_);\\n        uint balanceBefore = EIP20Interface(underlying_).balanceOf(address(this));\\n        token.transferFrom(from, address(this), amount);\\n\\n        bool success;\\n        assembly {\\n            switch returndatasize()\\n                case 0 {                       // This is a non-standard ERC-20\\n                    success := not(0)          // set success to true\\n                }\\n                case 32 {                      // This is a compliant ERC-20\\n                    returndatacopy(0, 0, 32)\\n                    success := mload(0)        // Set `success = returndata` of override external call\\n                }\\n                default {                      // This is an excessively non-compliant ERC-20, revert.\\n                    revert(0, 0)\\n                }\\n        }\\n        require(success, \\\"TOKEN_TRANSFER_IN_FAILED\\\");\\n\\n        // Calculate the amount that was *actually* transferred\\n        uint balanceAfter = EIP20Interface(underlying_).balanceOf(address(this));\\n        return balanceAfter - balanceBefore;   // underflow already checked above, just subtract\\n    }\\n\\n    /**\\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\\n     *      it is >= amount, this should not revert in normal conditions.\\n     *\\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n     */\\n    function doTransferOut(address payable to, uint amount) virtual override internal {\\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\\n        token.transfer(to, amount);\\n\\n        bool success;\\n        assembly {\\n            switch returndatasize()\\n                case 0 {                      // This is a non-standard ERC-20\\n                    success := not(0)          // set success to true\\n                }\\n                case 32 {                     // This is a compliant ERC-20\\n                    returndatacopy(0, 0, 32)\\n                    success := mload(0)        // Set `success = returndata` of override external call\\n                }\\n                default {                     // This is an excessively non-compliant ERC-20, revert.\\n                    revert(0, 0)\\n                }\\n        }\\n        require(success, \\\"TOKEN_TRANSFER_OUT_FAILED\\\");\\n    }\\n\\n    /**\\n    * @notice Admin call to delegate the votes of the COMP-like underlying\\n    * @param compLikeDelegatee The address to delegate votes to\\n    * @dev CTokens whose underlying are not CompLike should revert here\\n    */\\n    function _delegateCompLikeTo(address compLikeDelegatee) external {\\n        require(msg.sender == admin, \\\"only the admin may set the comp-like delegate\\\");\\n        CompLike(underlying).delegate(compLikeDelegatee);\\n    }\\n}\\n\",\"keccak256\":\"0x73fb5617eaee108a1381986053d5867db329aa0d3e59b59ffe1bf4da0553d94b\",\"license\":\"BSD-3-Clause\"},\"contracts/CToken.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./ComptrollerInterface.sol\\\";\\nimport \\\"./CTokenInterfaces.sol\\\";\\nimport \\\"./ErrorReporter.sol\\\";\\nimport \\\"./EIP20Interface.sol\\\";\\nimport \\\"./InterestRateModel.sol\\\";\\nimport \\\"./ExponentialNoError.sol\\\";\\n\\n/**\\n * @title Compound's CToken Contract\\n * @notice Abstract base for CTokens\\n * @author Compound\\n */\\nabstract contract CToken is CTokenInterface, ExponentialNoError, TokenErrorReporter {\\n    /**\\n     * @notice Initialize the money market\\n     * @param comptroller_ The address of the Comptroller\\n     * @param interestRateModel_ The address of the interest rate model\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n     * @param name_ EIP-20 name of this token\\n     * @param symbol_ EIP-20 symbol of this token\\n     * @param decimals_ EIP-20 decimal precision of this token\\n     */\\n    function initialize(ComptrollerInterface comptroller_,\\n                        InterestRateModel interestRateModel_,\\n                        uint initialExchangeRateMantissa_,\\n                        string memory name_,\\n                        string memory symbol_,\\n                        uint8 decimals_) public {\\n        require(msg.sender == admin, \\\"only admin may initialize the market\\\");\\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \\\"market may only be initialized once\\\");\\n\\n        // Set initial exchange rate\\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\\n        require(initialExchangeRateMantissa > 0, \\\"initial exchange rate must be greater than zero.\\\");\\n\\n        // Set the comptroller\\n        uint err = _setComptroller(comptroller_);\\n        require(err == NO_ERROR, \\\"setting comptroller failed\\\");\\n\\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\\n        accrualBlockNumber = getBlockNumber();\\n        borrowIndex = mantissaOne;\\n\\n        // Set the interest rate model (depends on block number / borrow index)\\n        err = _setInterestRateModelFresh(interestRateModel_);\\n        require(err == NO_ERROR, \\\"setting interest rate model failed\\\");\\n\\n        name = name_;\\n        symbol = symbol_;\\n        decimals = decimals_;\\n\\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\\n        _notEntered = true;\\n    }\\n\\n    /**\\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\\n     * @dev Called by both `transfer` and `transferFrom` internally\\n     * @param spender The address of the account performing the transfer\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param tokens The number of tokens to transfer\\n     * @return 0 if the transfer succeeded, else revert\\n     */\\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\\n        /* Fail if transfer not allowed */\\n        uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\\n        if (allowed != 0) {\\n            revert TransferComptrollerRejection(allowed);\\n        }\\n\\n        /* Do not allow self-transfers */\\n        if (src == dst) {\\n            revert TransferNotAllowed();\\n        }\\n\\n        /* Get the allowance, infinite for the account owner */\\n        uint startingAllowance = 0;\\n        if (spender == src) {\\n            startingAllowance = type(uint).max;\\n        } else {\\n            startingAllowance = transferAllowances[src][spender];\\n        }\\n\\n        /* Do the calculations, checking for {under,over}flow */\\n        uint allowanceNew = startingAllowance - tokens;\\n        uint srcTokensNew = accountTokens[src] - tokens;\\n        uint dstTokensNew = accountTokens[dst] + tokens;\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        accountTokens[src] = srcTokensNew;\\n        accountTokens[dst] = dstTokensNew;\\n\\n        /* Eat some of the allowance (if necessary) */\\n        if (startingAllowance != type(uint).max) {\\n            transferAllowances[src][spender] = allowanceNew;\\n        }\\n\\n        /* We emit a Transfer event */\\n        emit Transfer(src, dst, tokens);\\n\\n        // unused function\\n        // comptroller.transferVerify(address(this), src, dst, tokens);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transfer(address dst, uint256 amount) override external nonReentrant returns (bool) {\\n        return transferTokens(msg.sender, msg.sender, dst, amount) == NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transferFrom(address src, address dst, uint256 amount) override external nonReentrant returns (bool) {\\n        return transferTokens(msg.sender, src, dst, amount) == NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\n     * @dev This will overwrite the approval amount for `spender`\\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n     * @param spender The address of the account which may transfer tokens\\n     * @param amount The number of tokens that are approved (uint256.max means infinite)\\n     * @return Whether or not the approval succeeded\\n     */\\n    function approve(address spender, uint256 amount) override external returns (bool) {\\n        address src = msg.sender;\\n        transferAllowances[src][spender] = amount;\\n        emit Approval(src, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Get the current allowance from `owner` for `spender`\\n     * @param owner The address of the account which owns the tokens to be spent\\n     * @param spender The address of the account which may transfer tokens\\n     * @return The number of tokens allowed to be spent (-1 means infinite)\\n     */\\n    function allowance(address owner, address spender) override external view returns (uint256) {\\n        return transferAllowances[owner][spender];\\n    }\\n\\n    /**\\n     * @notice Get the token balance of the `owner`\\n     * @param owner The address of the account to query\\n     * @return The number of tokens owned by `owner`\\n     */\\n    function balanceOf(address owner) override external view returns (uint256) {\\n        return accountTokens[owner];\\n    }\\n\\n    /**\\n     * @notice Get the underlying balance of the `owner`\\n     * @dev This also accrues interest in a transaction\\n     * @param owner The address of the account to query\\n     * @return The amount of underlying owned by `owner`\\n     */\\n    function balanceOfUnderlying(address owner) override external returns (uint) {\\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\\n        return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\\n    }\\n\\n    /**\\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\\n     * @param account Address of the account to snapshot\\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\\n     */\\n    function getAccountSnapshot(address account) override external view returns (uint, uint, uint, uint) {\\n        return (\\n            NO_ERROR,\\n            accountTokens[account],\\n            borrowBalanceStoredInternal(account),\\n            exchangeRateStoredInternal()\\n        );\\n    }\\n\\n    /**\\n     * @dev Function to simply retrieve block number\\n     *  This exists mainly for inheriting test contracts to stub this result.\\n     */\\n    function getBlockNumber() virtual internal view returns (uint) {\\n        return block.number;\\n    }\\n\\n    /**\\n     * @notice Returns the current per-block borrow interest rate for this cToken\\n     * @return The borrow interest rate per block, scaled by 1e18\\n     */\\n    function borrowRatePerBlock() override external view returns (uint) {\\n        return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\\n    }\\n\\n    /**\\n     * @notice Returns the current per-block supply interest rate for this cToken\\n     * @return The supply interest rate per block, scaled by 1e18\\n     */\\n    function supplyRatePerBlock() override external view returns (uint) {\\n        return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\\n    }\\n\\n    /**\\n     * @notice Returns the current total borrows plus accrued interest\\n     * @return The total borrows with interest\\n     */\\n    function totalBorrowsCurrent() override external nonReentrant returns (uint) {\\n        accrueInterest();\\n        return totalBorrows;\\n    }\\n\\n    /**\\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\\n     * @param account The address whose balance should be calculated after updating borrowIndex\\n     * @return The calculated balance\\n     */\\n    function borrowBalanceCurrent(address account) override external nonReentrant returns (uint) {\\n        accrueInterest();\\n        return borrowBalanceStored(account);\\n    }\\n\\n    /**\\n     * @notice Return the borrow balance of account based on stored data\\n     * @param account The address whose balance should be calculated\\n     * @return The calculated balance\\n     */\\n    function borrowBalanceStored(address account) override public view returns (uint) {\\n        return borrowBalanceStoredInternal(account);\\n    }\\n\\n    /**\\n     * @notice Return the borrow balance of account based on stored data\\n     * @param account The address whose balance should be calculated\\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\\n     */\\n    function borrowBalanceStoredInternal(address account) internal view returns (uint) {\\n        /* Get borrowBalance and borrowIndex */\\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\\n\\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\\n         */\\n        if (borrowSnapshot.principal == 0) {\\n            return 0;\\n        }\\n\\n        /* Calculate new borrow balance using the interest index:\\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\\n         */\\n        uint principalTimesIndex = borrowSnapshot.principal * borrowIndex;\\n        return principalTimesIndex / borrowSnapshot.interestIndex;\\n    }\\n\\n    /**\\n     * @notice Accrue interest then return the up-to-date exchange rate\\n     * @return Calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateCurrent() override public nonReentrant returns (uint) {\\n        accrueInterest();\\n        return exchangeRateStored();\\n    }\\n\\n    /**\\n     * @notice Calculates the exchange rate from the underlying to the CToken\\n     * @dev This function does not accrue interest before calculating the exchange rate\\n     * @return Calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateStored() override public view returns (uint) {\\n        return exchangeRateStoredInternal();\\n    }\\n\\n    /**\\n     * @notice Calculates the exchange rate from the underlying to the CToken\\n     * @dev This function does not accrue efore calculating the exchange rate\\n     * @return calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateStoredInternal() virtual internal view returns (uint) {\\n        uint _totalSupply = totalSupply;\\n        if (_totalSupply == 0) {\\n            /*\\n             * If there are no tokens minted:\\n             *  exchangeRate = initialExchangeRate\\n             */\\n            return initialExchangeRateMantissa;\\n        } else {\\n            /*\\n             * Otherwise:\\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\\n             */\\n            uint totalCash = getCashPrior();\\n            uint cashPlusBorrowsMinusReserves = totalCash + totalBorrows - totalReserves;\\n            uint exchangeRate = cashPlusBorrowsMinusReserves * expScale / _totalSupply;\\n\\n            return exchangeRate;\\n        }\\n    }\\n\\n    /**\\n     * @notice Get cash balance of this cToken in the underlying asset\\n     * @return The quantity of underlying asset owned by this contract\\n     */\\n    function getCash() override external view returns (uint) {\\n        return getCashPrior();\\n    }\\n\\n    /**\\n     * @notice Applies accrued interest to total borrows and reserves\\n     * @dev This calculates interest accrued from the last checkpointed block\\n     *   up to the current block and writes new checkpoint to storage.\\n     */\\n    function accrueInterest() virtual override public returns (uint) {\\n        /* Remember the initial block number */\\n        uint currentBlockNumber = getBlockNumber();\\n        uint accrualBlockNumberPrior = accrualBlockNumber;\\n\\n        /* Short-circuit accumulating 0 interest */\\n        if (accrualBlockNumberPrior == currentBlockNumber) {\\n            return NO_ERROR;\\n        }\\n\\n        /* Read the previous values out of storage */\\n        uint cashPrior = getCashPrior();\\n        uint borrowsPrior = totalBorrows;\\n        uint reservesPrior = totalReserves;\\n        uint borrowIndexPrior = borrowIndex;\\n\\n        /* Calculate the current borrow interest rate */\\n        uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\\n        require(borrowRateMantissa <= borrowRateMaxMantissa, \\\"borrow rate is absurdly high\\\");\\n\\n        /* Calculate the number of blocks elapsed since the last accrual */\\n        uint blockDelta = currentBlockNumber - accrualBlockNumberPrior;\\n\\n        /*\\n         * Calculate the interest accumulated into borrows and reserves and the new index:\\n         *  simpleInterestFactor = borrowRate * blockDelta\\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\\n         */\\n\\n        Exp memory simpleInterestFactor = mul_(Exp({mantissa: borrowRateMantissa}), blockDelta);\\n        uint interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);\\n        uint totalBorrowsNew = interestAccumulated + borrowsPrior;\\n        uint totalReservesNew = mul_ScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\\n        uint borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /* We write the previously calculated values into storage */\\n        accrualBlockNumber = currentBlockNumber;\\n        borrowIndex = borrowIndexNew;\\n        totalBorrows = totalBorrowsNew;\\n        totalReserves = totalReservesNew;\\n\\n        /* We emit an AccrueInterest event */\\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param mintAmount The amount of the underlying asset to supply\\n     */\\n    function mintInternal(uint mintAmount) internal nonReentrant {\\n        accrueInterest();\\n        // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\\n        mintFresh(msg.sender, mintAmount);\\n    }\\n\\n    /**\\n     * @notice User supplies assets into the market and receives cTokens in exchange\\n     * @dev Assumes interest has already been accrued up to the current block\\n     * @param minter The address of the account which is supplying the assets\\n     * @param mintAmount The amount of the underlying asset to supply\\n     */\\n    function mintFresh(address minter, uint mintAmount) internal virtual {\\n        /* Fail if mint not allowed */\\n        uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\\n        if (allowed != 0) {\\n            revert MintComptrollerRejection(allowed);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert MintFreshnessCheck();\\n        }\\n\\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         *  We call `doTransferIn` for the minter and the mintAmount.\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\\n         *  side-effects occurred. The function returns the amount actually transferred,\\n         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\\n         *  of cash.\\n         */\\n        uint actualMintAmount = doTransferIn(minter, mintAmount);\\n\\n        /*\\n         * We get the current exchange rate and calculate the number of cTokens to be minted:\\n         *  mintTokens = actualMintAmount / exchangeRate\\n         */\\n\\n        uint mintTokens = div_(actualMintAmount, exchangeRate);\\n\\n        /*\\n         * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\\n         *  totalSupplyNew = totalSupply + mintTokens\\n         *  accountTokensNew = accountTokens[minter] + mintTokens\\n         * And write them into storage\\n         */\\n        totalSupply = totalSupply + mintTokens;\\n        accountTokens[minter] = accountTokens[minter] + mintTokens;\\n\\n        /* We emit a Mint event, and a Transfer event */\\n        emit Mint(minter, actualMintAmount, mintTokens);\\n        emit Transfer(address(this), minter, mintTokens);\\n\\n        /* We call the defense hook */\\n        // unused function\\n        // comptroller.mintVerify(address(this), minter, actualMintAmount, mintTokens);\\n    }\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for the underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemTokens The number of cTokens to redeem into underlying\\n     */\\n    function redeemInternal(uint redeemTokens) internal nonReentrant {\\n        accrueInterest();\\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\\n        redeemFresh(payable(msg.sender), redeemTokens, 0);\\n    }\\n\\n    /**\\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n     * @param redeemAmount The amount of underlying to receive from redeeming cTokens\\n     */\\n    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant {\\n        accrueInterest();\\n        // redeemFresh emits redeem-specific logs on errors, so we don't need to\\n        redeemFresh(payable(msg.sender), 0, redeemAmount);\\n    }\\n\\n    /**\\n     * @notice User redeems cTokens in exchange for the underlying asset\\n     * @dev Assumes interest has already been accrued up to the current block\\n     * @param redeemer The address of the account which is redeeming the tokens\\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\\n     */\\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal virtual {\\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \\\"one of redeemTokensIn or redeemAmountIn must be zero\\\");\\n\\n        /* exchangeRate = invoke Exchange Rate Stored() */\\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal() });\\n\\n        uint redeemTokens;\\n        uint redeemAmount;\\n        /* If redeemTokensIn > 0: */\\n        if (redeemTokensIn > 0) {\\n            /*\\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\\n             *  redeemTokens = redeemTokensIn\\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\\n             */\\n            redeemTokens = redeemTokensIn;\\n            redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokensIn);\\n        } else {\\n            /*\\n             * We get the current exchange rate and calculate the amount to be redeemed:\\n             *  redeemTokens = redeemAmountIn / exchangeRate\\n             *  redeemAmount = redeemAmountIn\\n             */\\n            redeemTokens = div_(redeemAmountIn, exchangeRate);\\n            redeemAmount = redeemAmountIn;\\n        }\\n\\n        /* Fail if redeem not allowed */\\n        uint allowed = comptroller.redeemAllowed(address(this), redeemer, redeemTokens);\\n        if (allowed != 0) {\\n            revert RedeemComptrollerRejection(allowed);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert RedeemFreshnessCheck();\\n        }\\n\\n        /* Fail gracefully if protocol has insufficient cash */\\n        if (getCashPrior() < redeemAmount) {\\n            revert RedeemTransferOutNotPossible();\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n\\n        /*\\n         * We write the previously calculated values into storage.\\n         *  Note: Avoid token reentrancy attacks by writing reduced supply before external transfer.\\n         */\\n        totalSupply = totalSupply - redeemTokens;\\n        accountTokens[redeemer] = accountTokens[redeemer] - redeemTokens;\\n\\n        /*\\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n         *  On success, the cToken has redeemAmount less of cash.\\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         */\\n        doTransferOut(redeemer, redeemAmount);\\n\\n        /* We emit a Transfer event, and a Redeem event */\\n        emit Transfer(redeemer, address(this), redeemTokens);\\n        emit Redeem(redeemer, redeemAmount, redeemTokens);\\n\\n        /* We call the defense hook */\\n        comptroller.redeemVerify(address(this), redeemer, redeemAmount, redeemTokens);\\n    }\\n\\n    /**\\n      * @notice Sender borrows assets from the protocol to their own address\\n      * @param borrowAmount The amount of the underlying asset to borrow\\n      */\\n    function borrowInternal(uint borrowAmount) internal nonReentrant {\\n        accrueInterest();\\n        // borrowFresh emits borrow-specific logs on errors, so we don't need to\\n        borrowFresh(payable(msg.sender), borrowAmount);\\n    }\\n\\n    /**\\n      * @notice Users borrow assets from the protocol to their own address\\n      * @param borrowAmount The amount of the underlying asset to borrow\\n      */\\n    function borrowFresh(address payable borrower, uint borrowAmount) internal virtual {\\n        /* Fail if borrow not allowed */\\n        uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\\n        if (allowed != 0) {\\n            revert BorrowComptrollerRejection(allowed);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert BorrowFreshnessCheck();\\n        }\\n\\n        /* Fail gracefully if protocol has insufficient underlying cash */\\n        if (getCashPrior() < borrowAmount) {\\n            revert BorrowCashNotAvailable();\\n        }\\n\\n        /*\\n         * We calculate the new borrower and total borrow balances, failing on overflow:\\n         *  accountBorrowNew = accountBorrow + borrowAmount\\n         *  totalBorrowsNew = totalBorrows + borrowAmount\\n         */\\n        uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\\n        uint accountBorrowsNew = accountBorrowsPrev + borrowAmount;\\n        uint totalBorrowsNew = totalBorrows + borrowAmount;\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We write the previously calculated values into storage.\\n         *  Note: Avoid token reentrancy attacks by writing increased borrow before external transfer.\\n        `*/\\n        accountBorrows[borrower].principal = accountBorrowsNew;\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\n        totalBorrows = totalBorrowsNew;\\n\\n        /*\\n         * We invoke doTransferOut for the borrower and the borrowAmount.\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n         *  On success, the cToken borrowAmount less of cash.\\n         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         */\\n        doTransferOut(borrower, borrowAmount);\\n\\n        /* We emit a Borrow event */\\n        emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);\\n    }\\n\\n    /**\\n     * @notice Sender repays their own borrow\\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\\n     */\\n    function repayBorrowInternal(uint repayAmount) internal nonReentrant {\\n        accrueInterest();\\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\\n        repayBorrowFresh(msg.sender, msg.sender, repayAmount);\\n    }\\n\\n    /**\\n     * @notice Sender repays a borrow belonging to borrower\\n     * @param borrower the account with the debt being payed off\\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\\n     */\\n    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant {\\n        accrueInterest();\\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\\n        repayBorrowFresh(msg.sender, borrower, repayAmount);\\n    }\\n\\n    /**\\n     * @notice Borrows are repaid by another user (possibly the borrower).\\n     * @param payer the account paying off the borrow\\n     * @param borrower the account with the debt being payed off\\n     * @param repayAmount the amount of underlying tokens being returned, or -1 for the full outstanding amount\\n     * @return (uint) the actual repayment amount.\\n     */\\n    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal virtual returns (uint) {\\n\\n        /* Fail if repayBorrow not allowed */\\n        uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\\n        if (allowed != 0) {\\n            revert RepayBorrowComptrollerRejection(allowed);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert RepayBorrowFreshnessCheck();\\n        }\\n\\n        /* We fetch the amount the borrower owes, with accumulated interest */\\n        uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\\n\\n        /* If repayAmount == -1, repayAmount = accountBorrows */\\n        uint repayAmountFinal = repayAmount == type(uint).max ? accountBorrowsPrev : repayAmount;\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We call doTransferIn for the payer and the repayAmount\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n         *  On success, the cToken holds an additional repayAmount of cash.\\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         *   it returns the amount actually transferred, in case of a fee.\\n         */\\n        uint actualRepayAmount = doTransferIn(payer, repayAmountFinal);\\n\\n        /*\\n         * We calculate the new borrower and total borrow balances, failing on underflow:\\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\\n         */\\n        uint accountBorrowsNew = accountBorrowsPrev - actualRepayAmount;\\n        uint totalBorrowsNew = totalBorrows - actualRepayAmount;\\n\\n        /* We write the previously calculated values into storage */\\n        accountBorrows[borrower].principal = accountBorrowsNew;\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\n        totalBorrows = totalBorrowsNew;\\n\\n        /* We emit a RepayBorrow event */\\n        emit RepayBorrow(payer, borrower, actualRepayAmount, accountBorrowsNew, totalBorrowsNew);\\n\\n        return actualRepayAmount;\\n    }\\n\\n    /**\\n     * @notice The sender liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param borrower The borrower of this cToken to be liquidated\\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     */\\n    function liquidateBorrowInternal(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal nonReentrant {\\n        accrueInterest();\\n\\n        uint error = cTokenCollateral.accrueInterest();\\n        if (error != NO_ERROR) {\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\\n            revert LiquidateAccrueCollateralInterestFailed(error);\\n        }\\n\\n        // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\\n        liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\\n    }\\n\\n    /**\\n     * @notice The liquidator liquidates the borrowers collateral.\\n     *  The collateral seized is transferred to the liquidator.\\n     * @param borrower The borrower of this cToken to be liquidated\\n     * @param liquidator The address repaying the borrow and seizing collateral\\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\n     */\\n    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal {\\n        /* Fail if liquidate not allowed */\\n        uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);\\n        if (allowed != 0) {\\n            revert LiquidateComptrollerRejection(allowed);\\n        }\\n\\n        /* Verify market's block number equals current block number */\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert LiquidateFreshnessCheck();\\n        }\\n\\n        /* Verify cTokenCollateral market's block number equals current block number */\\n        if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\\n            revert LiquidateCollateralFreshnessCheck();\\n        }\\n\\n        /* Fail if borrower = liquidator */\\n        if (borrower == liquidator) {\\n            revert LiquidateLiquidatorIsBorrower();\\n        }\\n\\n        /* Fail if repayAmount = 0 */\\n        if (repayAmount == 0) {\\n            revert LiquidateCloseAmountIsZero();\\n        }\\n\\n        /* Fail if repayAmount = -1 */\\n        if (repayAmount == type(uint).max) {\\n            revert LiquidateCloseAmountIsUintMax();\\n        }\\n\\n        /* Fail if repayBorrow fails */\\n        uint actualRepayAmount = repayBorrowFresh(liquidator, borrower, repayAmount);\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /* We calculate the number of collateral tokens that will be seized */\\n        (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), actualRepayAmount);\\n        require(amountSeizeError == NO_ERROR, \\\"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\\\");\\n\\n        /* Revert if borrower collateral token balance < seizeTokens */\\n        require(cTokenCollateral.balanceOf(borrower) >= seizeTokens, \\\"LIQUIDATE_SEIZE_TOO_MUCH\\\");\\n\\n        // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\\n        if (address(cTokenCollateral) == address(this)) {\\n            seizeInternal(address(this), liquidator, borrower, seizeTokens);\\n        } else {\\n            require(cTokenCollateral.seize(liquidator, borrower, seizeTokens) == NO_ERROR, \\\"token seizure failed\\\");\\n        }\\n\\n        /* We emit a LiquidateBorrow event */\\n        emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(cTokenCollateral), seizeTokens);\\n    }\\n\\n    /**\\n     * @notice Transfers collateral tokens (this market) to the liquidator.\\n     * @dev Will fail unless called by another cToken during the process of liquidation.\\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\\n     * @param liquidator The account receiving seized collateral\\n     * @param borrower The account having collateral seized\\n     * @param seizeTokens The number of cTokens to seize\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function seize(address liquidator, address borrower, uint seizeTokens) override external nonReentrant returns (uint) {\\n        seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Transfers collateral tokens (this market) to the liquidator.\\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\\n     *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\\n     * @param liquidator The account receiving seized collateral\\n     * @param borrower The account having collateral seized\\n     * @param seizeTokens The number of cTokens to seize\\n     */\\n    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal {\\n        /* Fail if seize not allowed */\\n        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\\n        if (allowed != 0) {\\n            revert LiquidateSeizeComptrollerRejection(allowed);\\n        }\\n\\n        /* Fail if borrower = liquidator */\\n        if (borrower == liquidator) {\\n            revert LiquidateSeizeLiquidatorIsBorrower();\\n        }\\n\\n        /*\\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\\n         */\\n        uint protocolSeizeTokens = mul_(seizeTokens, Exp({mantissa: protocolSeizeShareMantissa}));\\n        uint liquidatorSeizeTokens = seizeTokens - protocolSeizeTokens;\\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\\n        uint protocolSeizeAmount = mul_ScalarTruncate(exchangeRate, protocolSeizeTokens);\\n        uint totalReservesNew = totalReserves + protocolSeizeAmount;\\n\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /* We write the calculated values into storage */\\n        totalReserves = totalReservesNew;\\n        totalSupply = totalSupply - protocolSeizeTokens;\\n        accountTokens[borrower] = accountTokens[borrower] - seizeTokens;\\n        accountTokens[liquidator] = accountTokens[liquidator] + liquidatorSeizeTokens;\\n\\n        /* Emit a Transfer event */\\n        emit Transfer(borrower, liquidator, liquidatorSeizeTokens);\\n        emit Transfer(borrower, address(this), protocolSeizeTokens);\\n        emit ReservesAdded(address(this), protocolSeizeAmount, totalReservesNew);\\n    }\\n\\n\\n    /*** Admin Functions ***/\\n\\n    /**\\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @param newPendingAdmin New pending admin.\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setPendingAdmin(address payable newPendingAdmin) override external returns (uint) {\\n        // Check caller = admin\\n        if (msg.sender != admin) {\\n            revert SetPendingAdminOwnerCheck();\\n        }\\n\\n        // Save current value, if any, for inclusion in log\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store pendingAdmin with value newPendingAdmin\\n        pendingAdmin = newPendingAdmin;\\n\\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\n      * @dev Admin function for pending admin to accept role and update admin\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _acceptAdmin() override external returns (uint) {\\n        // Check caller is pendingAdmin and pendingAdmin \\u2260 address(0)\\n        if (msg.sender != pendingAdmin || msg.sender == address(0)) {\\n            revert AcceptAdminPendingAdminCheck();\\n        }\\n\\n        // Save current values for inclusion in log\\n        address oldAdmin = admin;\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store admin with value pendingAdmin\\n        admin = pendingAdmin;\\n\\n        // Clear the pending value\\n        pendingAdmin = payable(address(0));\\n\\n        emit NewAdmin(oldAdmin, admin);\\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n      * @notice Sets a new comptroller for the market\\n      * @dev Admin function to set a new comptroller\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setComptroller(ComptrollerInterface newComptroller) override public returns (uint) {\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            revert SetComptrollerOwnerCheck();\\n        }\\n\\n        ComptrollerInterface oldComptroller = comptroller;\\n        // Ensure invoke comptroller.isComptroller() returns true\\n        require(newComptroller.isComptroller(), \\\"marker method returned false\\\");\\n\\n        // Set market's comptroller to newComptroller\\n        comptroller = newComptroller;\\n\\n        // Emit NewComptroller(oldComptroller, newComptroller)\\n        emit NewComptroller(oldComptroller, newComptroller);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\\n      * @dev Admin function to accrue interest and set a new reserve factor\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setReserveFactor(uint newReserveFactorMantissa) override external nonReentrant returns (uint) {\\n        accrueInterest();\\n        // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\\n        return _setReserveFactorFresh(newReserveFactorMantissa);\\n    }\\n\\n    /**\\n      * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\\n      * @dev Admin function to set a new reserve factor\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            revert SetReserveFactorAdminCheck();\\n        }\\n\\n        // Verify market's block number equals current block number\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert SetReserveFactorFreshCheck();\\n        }\\n\\n        // Check newReserveFactor \\u2264 maxReserveFactor\\n        if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\\n            revert SetReserveFactorBoundsCheck();\\n        }\\n\\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\\n        reserveFactorMantissa = newReserveFactorMantissa;\\n\\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Accrues interest and reduces reserves by transferring from msg.sender\\n     * @param addAmount Amount of addition to reserves\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\\n        accrueInterest();\\n\\n        // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\\n        _addReservesFresh(addAmount);\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice Add reserves by transferring from caller\\n     * @dev Requires fresh interest accrual\\n     * @param addAmount Amount of addition to reserves\\n     * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees\\n     */\\n    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\\n        // totalReserves + actualAddAmount\\n        uint totalReservesNew;\\n        uint actualAddAmount;\\n\\n        // We fail gracefully unless market's block number equals current block number\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert AddReservesFactorFreshCheck(actualAddAmount);\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        /*\\n         * We call doTransferIn for the caller and the addAmount\\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n         *  On success, the cToken holds an additional addAmount of cash.\\n         *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n         *  it returns the amount actually transferred, in case of a fee.\\n         */\\n\\n        actualAddAmount = doTransferIn(msg.sender, addAmount);\\n\\n        totalReservesNew = totalReserves + actualAddAmount;\\n\\n        // Store reserves[n+1] = reserves[n] + actualAddAmount\\n        totalReserves = totalReservesNew;\\n\\n        /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\\n\\n        /* Return (NO_ERROR, actualAddAmount) */\\n        return (NO_ERROR, actualAddAmount);\\n    }\\n\\n\\n    /**\\n     * @notice Accrues interest and reduces reserves by transferring to admin\\n     * @param reduceAmount Amount of reduction to reserves\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _reduceReserves(uint reduceAmount) override external nonReentrant returns (uint) {\\n        accrueInterest();\\n        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\\n        return _reduceReservesFresh(reduceAmount);\\n    }\\n\\n    /**\\n     * @notice Reduces reserves by transferring to admin\\n     * @dev Requires fresh interest accrual\\n     * @param reduceAmount Amount of reduction to reserves\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\\n        // totalReserves - reduceAmount\\n        uint totalReservesNew;\\n\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            revert ReduceReservesAdminCheck();\\n        }\\n\\n        // We fail gracefully unless market's block number equals current block number\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert ReduceReservesFreshCheck();\\n        }\\n\\n        // Fail gracefully if protocol has insufficient underlying cash\\n        if (getCashPrior() < reduceAmount) {\\n            revert ReduceReservesCashNotAvailable();\\n        }\\n\\n        // Check reduceAmount \\u2264 reserves[n] (totalReserves)\\n        if (reduceAmount > totalReserves) {\\n            revert ReduceReservesCashValidation();\\n        }\\n\\n        /////////////////////////\\n        // EFFECTS & INTERACTIONS\\n        // (No safe failures beyond this point)\\n\\n        totalReservesNew = totalReserves - reduceAmount;\\n\\n        // Store reserves[n+1] = reserves[n] - reduceAmount\\n        totalReserves = totalReservesNew;\\n\\n        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\n        doTransferOut(admin, reduceAmount);\\n\\n        emit ReservesReduced(admin, reduceAmount, totalReservesNew);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /**\\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\\n     * @dev Admin function to accrue interest and update the interest rate model\\n     * @param newInterestRateModel the new interest rate model to use\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) override public returns (uint) {\\n        accrueInterest();\\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\\n        return _setInterestRateModelFresh(newInterestRateModel);\\n    }\\n\\n    /**\\n     * @notice updates the interest rate model (*requires fresh interest accrual)\\n     * @dev Admin function to update the interest rate model\\n     * @param newInterestRateModel the new interest rate model to use\\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n     */\\n    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\\n\\n        // Used to store old model for use in the event that is emitted on success\\n        InterestRateModel oldInterestRateModel;\\n\\n        // Check caller is admin\\n        if (msg.sender != admin) {\\n            revert SetInterestRateModelOwnerCheck();\\n        }\\n\\n        // We fail gracefully unless market's block number equals current block number\\n        if (accrualBlockNumber != getBlockNumber()) {\\n            revert SetInterestRateModelFreshCheck();\\n        }\\n\\n        // Track the market's current interest rate model\\n        oldInterestRateModel = interestRateModel;\\n\\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\\n        require(newInterestRateModel.isInterestRateModel(), \\\"marker method returned false\\\");\\n\\n        // Set the interest rate model to newInterestRateModel\\n        interestRateModel = newInterestRateModel;\\n\\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\\n        emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\\n\\n        return NO_ERROR;\\n    }\\n\\n    /*** Safe Token ***/\\n\\n    /**\\n     * @notice Gets balance of this contract in terms of the underlying\\n     * @dev This excludes the value of the current message, if any\\n     * @return The quantity of underlying owned by this contract\\n     */\\n    function getCashPrior() virtual internal view returns (uint);\\n\\n    /**\\n     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\\n     *  This may revert due to insufficient balance or insufficient allowance.\\n     */\\n    function doTransferIn(address from, uint amount) virtual internal returns (uint);\\n\\n    /**\\n     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure rather than reverting.\\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\\n     */\\n    function doTransferOut(address payable to, uint amount) virtual internal;\\n\\n\\n    /*** Reentrancy Guard ***/\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     */\\n    modifier nonReentrant() virtual {\\n        require(_notEntered, \\\"re-entered\\\");\\n        _notEntered = false;\\n        _;\\n        _notEntered = true; // get a gas-refund post-Istanbul\\n    }\\n}\\n\",\"keccak256\":\"0x70099c30799c8e4f5db8f2fdd72f1e2dcaed9370bb652ee5e46ed66a116e861f\",\"license\":\"BSD-3-Clause\"},\"contracts/CTokenInterfaces.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./ComptrollerInterface.sol\\\";\\nimport \\\"./InterestRateModel.sol\\\";\\nimport \\\"./EIP20NonStandardInterface.sol\\\";\\nimport \\\"./ErrorReporter.sol\\\";\\n\\ncontract CTokenStorage {\\n    /**\\n     * @dev Guard variable for re-entrancy checks\\n     */\\n    bool internal _notEntered;\\n\\n    /**\\n     * @notice EIP-20 token name for this token\\n     */\\n    string public name;\\n\\n    /**\\n     * @notice EIP-20 token symbol for this token\\n     */\\n    string public symbol;\\n\\n    /**\\n     * @notice EIP-20 token decimals for this token\\n     */\\n    uint8 public decimals;\\n\\n    // Maximum borrow rate that can ever be applied (.0005% / block)\\n    uint internal constant borrowRateMaxMantissa = 0.0005e16;\\n\\n    // Maximum fraction of interest that can be set aside for reserves\\n    uint internal constant reserveFactorMaxMantissa = 1e18;\\n\\n    /**\\n     * @notice Administrator for this contract\\n     */\\n    address payable public admin;\\n\\n    /**\\n     * @notice Pending administrator for this contract\\n     */\\n    address payable public pendingAdmin;\\n\\n    /**\\n     * @notice Contract which oversees inter-cToken operations\\n     */\\n    ComptrollerInterface public comptroller;\\n\\n    /**\\n     * @notice Model which tells what the current interest rate should be\\n     */\\n    InterestRateModel public interestRateModel;\\n\\n    // Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\\n    uint internal initialExchangeRateMantissa;\\n\\n    /**\\n     * @notice Fraction of interest currently set aside for reserves\\n     */\\n    uint public reserveFactorMantissa;\\n\\n    /**\\n     * @notice Block number that interest was last accrued at\\n     */\\n    uint public accrualBlockNumber;\\n\\n    /**\\n     * @notice Accumulator of the total earned interest rate since the opening of the market\\n     */\\n    uint public borrowIndex;\\n\\n    /**\\n     * @notice Total amount of outstanding borrows of the underlying in this market\\n     */\\n    uint public totalBorrows;\\n\\n    /**\\n     * @notice Total amount of reserves of the underlying held in this market\\n     */\\n    uint public totalReserves;\\n\\n    /**\\n     * @notice Total number of tokens in circulation\\n     */\\n    uint public totalSupply;\\n\\n    // Official record of token balances for each account\\n    mapping (address => uint) internal accountTokens;\\n\\n    // Approved token transfer amounts on behalf of others\\n    mapping (address => mapping (address => uint)) internal transferAllowances;\\n\\n    /**\\n     * @notice Container for borrow balance information\\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\\n     */\\n    struct BorrowSnapshot {\\n        uint principal;\\n        uint interestIndex;\\n    }\\n\\n    // Mapping of account addresses to outstanding borrow balances\\n    mapping(address => BorrowSnapshot) internal accountBorrows;\\n\\n    /**\\n     * @notice Share of seized collateral that is added to reserves\\n     */\\n    uint public constant protocolSeizeShareMantissa = 2.8e16; //2.8%\\n}\\n\\nabstract contract CTokenInterface is CTokenStorage {\\n    /**\\n     * @notice Indicator that this is a CToken contract (for inspection)\\n     */\\n    bool public constant isCToken = true;\\n\\n\\n    /*** Market Events ***/\\n\\n    /**\\n     * @notice Event emitted when interest is accrued\\n     */\\n    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);\\n\\n    /**\\n     * @notice Event emitted when tokens are minted\\n     */\\n    event Mint(address minter, uint mintAmount, uint mintTokens);\\n\\n    /**\\n     * @notice Event emitted when tokens are redeemed\\n     */\\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\\n\\n    /**\\n     * @notice Event emitted when underlying is borrowed\\n     */\\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\\n\\n    /**\\n     * @notice Event emitted when a borrow is repaid\\n     */\\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\\n\\n    /**\\n     * @notice Event emitted when a borrow is liquidated\\n     */\\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);\\n\\n\\n    /*** Admin Events ***/\\n\\n    /**\\n     * @notice Event emitted when pendingAdmin is changed\\n     */\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\n    /**\\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\\n     */\\n    event NewAdmin(address oldAdmin, address newAdmin);\\n\\n    /**\\n     * @notice Event emitted when comptroller is changed\\n     */\\n    event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\\n\\n    /**\\n     * @notice Event emitted when interestRateModel is changed\\n     */\\n    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\\n\\n    /**\\n     * @notice Event emitted when the reserve factor is changed\\n     */\\n    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\\n\\n    /**\\n     * @notice Event emitted when the reserves are added\\n     */\\n    event ReservesAdded(address benefactor, uint addAmount, uint newTotalReserves);\\n\\n    /**\\n     * @notice Event emitted when the reserves are reduced\\n     */\\n    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\\n\\n    /**\\n     * @notice EIP20 Transfer event\\n     */\\n    event Transfer(address indexed from, address indexed to, uint amount);\\n\\n    /**\\n     * @notice EIP20 Approval event\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint amount);\\n\\n\\n    /*** User Interface ***/\\n\\n    function transfer(address dst, uint amount) virtual external returns (bool);\\n    function transferFrom(address src, address dst, uint amount) virtual external returns (bool);\\n    function approve(address spender, uint amount) virtual external returns (bool);\\n    function allowance(address owner, address spender) virtual external view returns (uint);\\n    function balanceOf(address owner) virtual external view returns (uint);\\n    function balanceOfUnderlying(address owner) virtual external returns (uint);\\n    function getAccountSnapshot(address account) virtual external view returns (uint, uint, uint, uint);\\n    function borrowRatePerBlock() virtual external view returns (uint);\\n    function supplyRatePerBlock() virtual external view returns (uint);\\n    function totalBorrowsCurrent() virtual external returns (uint);\\n    function borrowBalanceCurrent(address account) virtual external returns (uint);\\n    function borrowBalanceStored(address account) virtual external view returns (uint);\\n    function exchangeRateCurrent() virtual external returns (uint);\\n    function exchangeRateStored() virtual external view returns (uint);\\n    function getCash() virtual external view returns (uint);\\n    function accrueInterest() virtual external returns (uint);\\n    function seize(address liquidator, address borrower, uint seizeTokens) virtual external returns (uint);\\n\\n\\n    /*** Admin Functions ***/\\n\\n    function _setPendingAdmin(address payable newPendingAdmin) virtual external returns (uint);\\n    function _acceptAdmin() virtual external returns (uint);\\n    function _setComptroller(ComptrollerInterface newComptroller) virtual external returns (uint);\\n    function _setReserveFactor(uint newReserveFactorMantissa) virtual external returns (uint);\\n    function _reduceReserves(uint reduceAmount) virtual external returns (uint);\\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) virtual external returns (uint);\\n}\\n\\ncontract CErc20Storage {\\n    /**\\n     * @notice Underlying asset for this CToken\\n     */\\n    address public underlying;\\n}\\n\\n\\nabstract contract CErc20Interface is CErc20Storage {\\n\\n    /*** User Interface ***/\\n\\n    function mint(uint mintAmount) virtual external returns (uint);\\n    function redeem(uint redeemTokens) virtual external returns (uint);\\n    function redeemUnderlying(uint redeemAmount) virtual external returns (uint);\\n    function borrow(uint borrowAmount) virtual external returns (uint);\\n    function repayBorrow(uint repayAmount) virtual external returns (uint);\\n    function repayBorrowBehalf(address borrower, uint repayAmount) virtual external returns (uint);\\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) virtual external returns (uint);\\n    function sweepToken(EIP20NonStandardInterface token) virtual external;\\n\\n\\n    /*** Admin Functions ***/\\n\\n    function _addReserves(uint addAmount) virtual external returns (uint);\\n}\\n\\ncontract CDelegationStorage {\\n    /**\\n     * @notice Implementation address for this contract\\n     */\\n    address public implementation;\\n}\\n\\nabstract contract CDelegatorInterface is CDelegationStorage {\\n    /**\\n     * @notice Emitted when implementation is changed\\n     */\\n    event NewImplementation(address oldImplementation, address newImplementation);\\n\\n    /**\\n     * @notice Called by the admin to update the implementation of the delegator\\n     * @param implementation_ The address of the new implementation for delegation\\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\\n     */\\n    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) virtual external;\\n}\\n\\nabstract contract CDelegateInterface is CDelegationStorage {\\n    /**\\n     * @notice Called by the delegator on a delegate to initialize it for duty\\n     * @dev Should revert if any issues arise which make it unfit for delegation\\n     * @param data The encoded bytes data for any initialization\\n     */\\n    function _becomeImplementation(bytes memory data) virtual external;\\n\\n    /**\\n     * @notice Called by the delegator on a delegate to forfeit its responsibility\\n     */\\n    function _resignImplementation() virtual external;\\n}\\n\",\"keccak256\":\"0x6bce379bddcd3676f96fddd3c020d1d8b06b97dd8a43fbfdcefb4c1218fa6f4a\",\"license\":\"BSD-3-Clause\"},\"contracts/ComptrollerInterface.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nabstract contract ComptrollerInterface {\\n    /// @notice Indicator that this is a Comptroller contract (for inspection)\\n    bool public constant isComptroller = true;\\n\\n    /*** Assets You Are In ***/\\n\\n    function enterMarkets(address[] calldata cTokens) virtual external returns (uint[] memory);\\n    function exitMarket(address cToken) virtual external returns (uint);\\n\\n    /*** Policy Hooks ***/\\n\\n    function mintAllowed(address cToken, address minter, uint mintAmount) virtual external returns (uint);\\n    function mintVerify(address cToken, address minter, uint mintAmount, uint mintTokens) virtual external;\\n\\n    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) virtual external returns (uint);\\n    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) virtual external;\\n\\n    function borrowAllowed(address cToken, address borrower, uint borrowAmount) virtual external returns (uint);\\n    function borrowVerify(address cToken, address borrower, uint borrowAmount) virtual external;\\n\\n    function repayBorrowAllowed(\\n        address cToken,\\n        address payer,\\n        address borrower,\\n        uint repayAmount) virtual external returns (uint);\\n    function repayBorrowVerify(\\n        address cToken,\\n        address payer,\\n        address borrower,\\n        uint repayAmount,\\n        uint borrowerIndex) virtual external;\\n\\n    function liquidateBorrowAllowed(\\n        address cTokenBorrowed,\\n        address cTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint repayAmount) virtual external returns (uint);\\n    function liquidateBorrowVerify(\\n        address cTokenBorrowed,\\n        address cTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint repayAmount,\\n        uint seizeTokens) virtual external;\\n\\n    function seizeAllowed(\\n        address cTokenCollateral,\\n        address cTokenBorrowed,\\n        address liquidator,\\n        address borrower,\\n        uint seizeTokens) virtual external returns (uint);\\n    function seizeVerify(\\n        address cTokenCollateral,\\n        address cTokenBorrowed,\\n        address liquidator,\\n        address borrower,\\n        uint seizeTokens) virtual external;\\n\\n    function transferAllowed(address cToken, address src, address dst, uint transferTokens) virtual external returns (uint);\\n    function transferVerify(address cToken, address src, address dst, uint transferTokens) virtual external;\\n\\n    /*** Liquidity/Liquidation Calculations ***/\\n\\n    function liquidateCalculateSeizeTokens(\\n        address cTokenBorrowed,\\n        address cTokenCollateral,\\n        uint repayAmount) virtual external view returns (uint, uint);\\n}\\n\",\"keccak256\":\"0x4111ff0414696caca696cf36ecf3add15133933b51ba57c56cfb08989c82d44f\",\"license\":\"BSD-3-Clause\"},\"contracts/EIP20Interface.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\n/**\\n * @title ERC 20 Token Standard Interface\\n *  https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface EIP20Interface {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n      * @notice Get the total number of tokens in circulation\\n      * @return The supply of tokens\\n      */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the balance of the specified address\\n     * @param owner The address from which the balance will be retrieved\\n     * @return balance The balance\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      * @return success Whether or not the transfer succeeded\\n      */\\n    function transfer(address dst, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `src` to `dst`\\n      * @param src The address of the source account\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      * @return success Whether or not the transfer succeeded\\n      */\\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Approve `spender` to transfer up to `amount` from `src`\\n      * @dev This will overwrite the approval amount for `spender`\\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n      * @param spender The address of the account which may transfer tokens\\n      * @param amount The number of tokens that are approved (-1 means infinite)\\n      * @return success Whether or not the approval succeeded\\n      */\\n    function approve(address spender, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Get the current allowance from `owner` for `spender`\\n      * @param owner The address of the account which owns the tokens to be spent\\n      * @param spender The address of the account which may transfer tokens\\n      * @return remaining The number of tokens allowed to be spent (-1 means infinite)\\n      */\\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n}\\n\",\"keccak256\":\"0xf44fc7783d4a0060119f0096a122c3f305c7a03da75aa21408393d8d7a2e649b\",\"license\":\"BSD-3-Clause\"},\"contracts/EIP20NonStandardInterface.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\n/**\\n * @title EIP20NonStandardInterface\\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n */\\ninterface EIP20NonStandardInterface {\\n\\n    /**\\n     * @notice Get the total number of tokens in circulation\\n     * @return The supply of tokens\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the balance of the specified address\\n     * @param owner The address from which the balance will be retrieved\\n     * @return balance The balance\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    ///\\n    /// !!!!!!!!!!!!!!\\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\\n    /// !!!!!!!!!!!!!!\\n    ///\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      */\\n    function transfer(address dst, uint256 amount) external;\\n\\n    ///\\n    /// !!!!!!!!!!!!!!\\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\\n    /// !!!!!!!!!!!!!!\\n    ///\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `src` to `dst`\\n      * @param src The address of the source account\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      */\\n    function transferFrom(address src, address dst, uint256 amount) external;\\n\\n    /**\\n      * @notice Approve `spender` to transfer up to `amount` from `src`\\n      * @dev This will overwrite the approval amount for `spender`\\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n      * @param spender The address of the account which may transfer tokens\\n      * @param amount The number of tokens that are approved\\n      * @return success Whether or not the approval succeeded\\n      */\\n    function approve(address spender, uint256 amount) external returns (bool success);\\n\\n    /**\\n      * @notice Get the current allowance from `owner` for `spender`\\n      * @param owner The address of the account which owns the tokens to be spent\\n      * @param spender The address of the account which may transfer tokens\\n      * @return remaining The number of tokens allowed to be spent\\n      */\\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n}\\n\",\"keccak256\":\"0x5ce25bb36a4ec9490617567a24b55bc813e943bcd4411e060afffe122bea0416\",\"license\":\"BSD-3-Clause\"},\"contracts/ErrorReporter.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\ncontract ComptrollerErrorReporter {\\n    enum Error {\\n        NO_ERROR,\\n        UNAUTHORIZED,\\n        COMPTROLLER_MISMATCH,\\n        INSUFFICIENT_SHORTFALL,\\n        INSUFFICIENT_LIQUIDITY,\\n        INVALID_CLOSE_FACTOR,\\n        INVALID_COLLATERAL_FACTOR,\\n        INVALID_LIQUIDATION_INCENTIVE,\\n        MARKET_NOT_ENTERED, // no longer possible\\n        MARKET_NOT_LISTED,\\n        MARKET_ALREADY_LISTED,\\n        MATH_ERROR,\\n        NONZERO_BORROW_BALANCE,\\n        PRICE_ERROR,\\n        REJECTION,\\n        SNAPSHOT_ERROR,\\n        TOO_MANY_ASSETS,\\n        TOO_MUCH_REPAY\\n    }\\n\\n    enum FailureInfo {\\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\\n        EXIT_MARKET_BALANCE_OWED,\\n        EXIT_MARKET_REJECTION,\\n        SET_CLOSE_FACTOR_OWNER_CHECK,\\n        SET_CLOSE_FACTOR_VALIDATION,\\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\\n        SET_COLLATERAL_FACTOR_VALIDATION,\\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\\n        SET_IMPLEMENTATION_OWNER_CHECK,\\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\\n        SET_MAX_ASSETS_OWNER_CHECK,\\n        SET_PENDING_ADMIN_OWNER_CHECK,\\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\\n        SET_PRICE_ORACLE_OWNER_CHECK,\\n        SUPPORT_MARKET_EXISTS,\\n        SUPPORT_MARKET_OWNER_CHECK,\\n        SET_PAUSE_GUARDIAN_OWNER_CHECK\\n    }\\n\\n    /**\\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\\n      **/\\n    event Failure(uint error, uint info, uint detail);\\n\\n    /**\\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\\n      */\\n    function fail(Error err, FailureInfo info) internal returns (uint) {\\n        emit Failure(uint(err), uint(info), 0);\\n\\n        return uint(err);\\n    }\\n\\n    /**\\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\\n      */\\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\\n        emit Failure(uint(err), uint(info), opaqueError);\\n\\n        return uint(err);\\n    }\\n}\\n\\ncontract TokenErrorReporter {\\n    uint public constant NO_ERROR = 0; // support legacy return codes\\n\\n    error TransferComptrollerRejection(uint256 errorCode);\\n    error TransferNotAllowed();\\n    error TransferNotEnough();\\n    error TransferTooMuch();\\n\\n    error MintComptrollerRejection(uint256 errorCode);\\n    error MintFreshnessCheck();\\n\\n    error RedeemComptrollerRejection(uint256 errorCode);\\n    error RedeemFreshnessCheck();\\n    error RedeemTransferOutNotPossible();\\n\\n    error BorrowComptrollerRejection(uint256 errorCode);\\n    error BorrowFreshnessCheck();\\n    error BorrowCashNotAvailable();\\n\\n    error RepayBorrowComptrollerRejection(uint256 errorCode);\\n    error RepayBorrowFreshnessCheck();\\n\\n    error LiquidateComptrollerRejection(uint256 errorCode);\\n    error LiquidateFreshnessCheck();\\n    error LiquidateCollateralFreshnessCheck();\\n    error LiquidateAccrueBorrowInterestFailed(uint256 errorCode);\\n    error LiquidateAccrueCollateralInterestFailed(uint256 errorCode);\\n    error LiquidateLiquidatorIsBorrower();\\n    error LiquidateCloseAmountIsZero();\\n    error LiquidateCloseAmountIsUintMax();\\n    error LiquidateRepayBorrowFreshFailed(uint256 errorCode);\\n\\n    error LiquidateSeizeComptrollerRejection(uint256 errorCode);\\n    error LiquidateSeizeLiquidatorIsBorrower();\\n\\n    error AcceptAdminPendingAdminCheck();\\n\\n    error SetComptrollerOwnerCheck();\\n    error SetPendingAdminOwnerCheck();\\n\\n    error SetReserveFactorAdminCheck();\\n    error SetReserveFactorFreshCheck();\\n    error SetReserveFactorBoundsCheck();\\n\\n    error AddReservesFactorFreshCheck(uint256 actualAddAmount);\\n\\n    error ReduceReservesAdminCheck();\\n    error ReduceReservesFreshCheck();\\n    error ReduceReservesCashNotAvailable();\\n    error ReduceReservesCashValidation();\\n\\n    error SetInterestRateModelOwnerCheck();\\n    error SetInterestRateModelFreshCheck();\\n\\n    //Accountant Error Codes\\n    error AccountantSupplyError(uint256 borrowAmount);\\n    error AccountantRedeemError(uint256 redeemAmount);\\n}\\n\",\"keccak256\":\"0x4782810ec7d04cb8c3eeb4660fb6650f8b2edfd8b1e2d123dcbe93eff29373d8\",\"license\":\"BSD-3-Clause\"},\"contracts/ExponentialNoError.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\n/**\\n * @title Exponential module for storing fixed-precision decimals\\n * @author Compound\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\n *         `Exp({mantissa: 5100000000000000000})`.\\n */\\ncontract ExponentialNoError {\\n    uint constant expScale = 1e18;\\n    uint constant doubleScale = 1e36;\\n    uint constant halfExpScale = expScale/2;\\n    uint constant mantissaOne = expScale;\\n\\n    struct Exp {\\n        uint mantissa;\\n    }\\n\\n    struct Double {\\n        uint mantissa;\\n    }\\n\\n    /**\\n     * @dev Truncates the given exp to a whole number value.\\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\\n     */\\n    function truncate(Exp memory exp) pure internal returns (uint) {\\n        // Note: We are not using careful math here as we're performing a division that cannot fail\\n        return exp.mantissa / expScale;\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\n     */\\n    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\\n        Exp memory product = mul_(a, scalar);\\n        return truncate(product);\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\\n     */\\n    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\\n        Exp memory product = mul_(a, scalar);\\n        return add_(truncate(product), addend);\\n    }\\n\\n    /**\\n     * @dev Checks if first Exp is less than second Exp.\\n     */\\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\n        return left.mantissa < right.mantissa;\\n    }\\n\\n    /**\\n     * @dev Checks if left Exp <= right Exp.\\n     */\\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\n        return left.mantissa <= right.mantissa;\\n    }\\n\\n    /**\\n     * @dev Checks if left Exp > right Exp.\\n     */\\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\\n        return left.mantissa > right.mantissa;\\n    }\\n\\n    /**\\n     * @dev returns true if Exp is exactly zero\\n     */\\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\\n        return value.mantissa == 0;\\n    }\\n\\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\\n        require(n < 2**224, errorMessage);\\n        return uint224(n);\\n    }\\n\\n    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\\n        require(n < 2**32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function add_(uint a, uint b) pure internal returns (uint) {\\n        return a + b;\\n    }\\n\\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function sub_(uint a, uint b) pure internal returns (uint) {\\n        return a - b;\\n    }\\n\\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\\n    }\\n\\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: mul_(a.mantissa, b)});\\n    }\\n\\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\\n        return mul_(a, b.mantissa) / expScale;\\n    }\\n\\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\\n    }\\n\\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\\n        return Double({mantissa: mul_(a.mantissa, b)});\\n    }\\n\\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\\n        return mul_(a, b.mantissa) / doubleScale;\\n    }\\n\\n    function mul_(uint a, uint b) pure internal returns (uint) {\\n        return a * b;\\n    }\\n\\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\\n    }\\n\\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\\n        return Exp({mantissa: div_(a.mantissa, b)});\\n    }\\n\\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\\n        return div_(mul_(a, expScale), b.mantissa);\\n    }\\n\\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\\n    }\\n\\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\\n        return Double({mantissa: div_(a.mantissa, b)});\\n    }\\n\\n    function div_(uint a, Double memory b) pure internal returns (uint) {\\n        return div_(mul_(a, doubleScale), b.mantissa);\\n    }\\n\\n    function div_(uint a, uint b) pure internal returns (uint) {\\n        return a / b;\\n    }\\n\\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\\n    }\\n}\\n\",\"keccak256\":\"0x3a05062282ef8cbf6ec372abc73387ac8105a7eb0ea0f38069ebfd0f434ff98b\",\"license\":\"BSD-3-Clause\"},\"contracts/InterestRateModel.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\n/**\\n  * @title Compound's InterestRateModel Interface\\n  * @author Compound\\n  */\\nabstract contract InterestRateModel {\\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\\n    bool public constant isInterestRateModel = true;\\n\\n    /**\\n      * @notice Calculates the current borrow interest rate per block\\n      * @param cash The total amount of cash the market has\\n      * @param borrows The total amount of borrows the market has outstanding\\n      * @param reserves The total amount of reserves the market has\\n      * @return The borrow rate per block (as a percentage, and scaled by 1e18)\\n      */\\n    function getBorrowRate(uint cash, uint borrows, uint reserves) virtual external view returns (uint);\\n\\n    /**\\n      * @notice Calculates the current supply interest rate per block\\n      * @param cash The total amount of cash the market has\\n      * @param borrows The total amount of borrows the market has outstanding\\n      * @param reserves The total amount of reserves the market has\\n      * @param reserveFactorMantissa The current reserve factor the market has\\n      * @return The supply rate per block (as a percentage, and scaled by 1e18)\\n      */\\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) virtual external view returns (uint);\\n}\\n\",\"keccak256\":\"0x470821c8ff2120381ead6f54dba5c7b4fc0209682062bde51ea20291176aa0be\",\"license\":\"BSD-3-Clause\"},\"contracts/NoteInterest.sol\":{\"content\":\"pragma solidity ^0.8.10;\\n\\nimport \\\"./InterestRateModel.sol\\\";\\nimport \\\"./SimplePriceOracle.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n  * @title note's interest rate model contract\\n  * @author canto\\n  */\\n\\n\\ncontract NoteRateModel is InterestRateModel {\\n\\n    using SafeMath for uint;\\n\\n    event NewInterestParams(uint baserateperblock);\\n\\n    /**\\n    * @notice administrator for this contract\\n    */\\n    address private admin;\\n\\n    /**\\n     * @notice The approximate number of blocks per year that is assumed by the interest rate model\\n     */\\n    uint public constant blocksPerYear = 5256000;\\n\\n    /**\\n     * @notice The variable to keep track of the last update on Note's interest rate, initialized at the current block number\\n     */\\n    uint public lastUpdateBlock = block.number;\\n\\n    /**\\n     * @notice baseRatePerYear The per year interest rate, as a mantissa (scaled by 1e18)\\n     */\\n    uint public baseRatePerYear;\\n\\n    /**\\n     * @notice baseRatePerBlock The per block interest rate, as a mantissa (scaled by 1e18)\\n     */\\n    uint public baseRatePerBlock;\\n\\n    /**\\n     * @notice The level of aggressiveness to adjust interest rate according to twap's deviation from the peg\\n     */\\n    uint public adjusterCoefficient; // set by admin, default 1\\n\\n    /**\\n     * @notice The frequency of updating Note's base rate\\n     */\\n    uint public updateFrequency; // set by admin, default 24 hours\\n\\n\\n    /**\\n     * @notice The CToken identifier for Note\\n     */\\n    CToken public note;\\n\\n    /// @notice Emitted when base rate is changed by admin\\n    event NewBaseRate(uint oldBaseRateMantissa, uint newBaseRateMantissa);\\n\\n    /// @notice Emitted when adjuster coefficient is changed by admin\\n    event NewAdjusterCoefficient(uint oldAdjusterCoefficient, uint newAdjusterCoefficient);\\n\\n    /// @notice Emitted when update frequency is changed by admin\\n    event NewUpdateFrequency(uint oldUpdateFrequency, uint newUpdateFrequency);\\n\\n    /**\\n     * @notice Construct an interest rate model\\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18), set by admin, default 2%\\n     */\\n    constructor(uint baseRatePerYear) {\\n        baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\\n        emit NewInterestParams(baseRatePerBlock);\\n        admin = msg.sender;\\n    }\\n\\n    /**\\n      * @notice Get the underlying price of a cToken asset\\n      * @param cToken The cToken to get the underlying price of\\n      * @return The underlying asset price mantissa (scaled by 1e18).\\n      *  Zero means the price is unavailable.\\n      */\\n    // function getUnderlyingPrice(CToken cToken);\\n\\n    /**\\n     * @notice Calculates the current borrow rate per block, with the error code expected by the market\\n     * @notice The following parameters are irrelevent for calculating Note's interest rate. They are passed in to align with the standard function definition `getBorrowRate` in InterestRateModel\\n     * @return Note's borrow rate percentage per block as a mantissa (scaled by 1e18)\\n     */\\n    function getBorrowRate(uint cash, uint borrows, uint reserves) public view override returns (uint) {\\n        // Gets the Note/gUSDC TWAP in a given interval, as a mantissa (scaled by 1e18)\\n        // uint twapMantissa = getUnderlyingPrice(note);\\n        uint rand = uint(keccak256(abi.encodePacked(msg.sender))) % 100;\\n        uint ir = (100 - rand).mul(adjusterCoefficient).add(baseRatePerYear).mul(1e16);\\n        uint newRatePerYear = ir >= 0 ? ir : 0;\\n        // convert it to base rate per block\\n        uint newRatePerBlock = newRatePerYear.div(blocksPerYear);\\n        return newRatePerBlock;\\n    }\\n\\n\\n    /**\\n     * @notice Calculates the current supply rate per block, which is the same as the borrow rate\\n     * @notice The following parameters are irrelevent for calculating Note's interest rate. They are passed in to align with the standard function definition `getSupplyRate` in InterestRateModel\\n     * @return Note's supply rate percentage per block as a mantissa (scaled by 1e18)\\n     */\\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) external view override returns (uint) {\\n      return getBorrowRate(cash, borrows, reserves);\\n    }\\n\\n    /**\\n     * @notice Updates the Note's base rate per year at a given interval\\n     * @notice This function should be called at a given interval (TBD)\\n     * @param newBaseRatePerYear The new base rate per year of Note\\n     */\\n    function updateBaseRate(uint newBaseRatePerYear) public {\\n        // check the current block number\\n        uint blockNumber = block.number;\\n        uint deltaBlocks = blockNumber.sub(lastUpdateBlock);\\n\\n        if (deltaBlocks > updateFrequency) {\\n            // pass in a base rate per year\\n            baseRatePerYear = newBaseRatePerYear;\\n            lastUpdateBlock = blockNumber;\\n            emit NewInterestParams(baseRatePerYear);\\n        }\\n    }\\n\\n\\n    // Admin functions\\n\\n    /**\\n      * @notice Sets the base interest rate for Note\\n      * @dev Admin function to set per-market base interest rate\\n      * @param newBaseRateMantissa The new base interest rate, scaled by 1e18\\n      */\\n    function _setBaseRatePerYear(uint newBaseRateMantissa) external {\\n        // Check caller is admin\\n        require(msg.sender == admin, \\\"only the admin may set the base rate\\\");\\n        uint oldBaseRatePerYear = baseRatePerYear;\\n        baseRatePerYear = newBaseRateMantissa;\\n        emit NewBaseRate(oldBaseRatePerYear, baseRatePerYear);\\n    }\\n\\n    /**\\n      * @notice Sets the adjuster coefficient for Note\\n      * @dev Admin function to set per-market adjuster coefficient\\n      * @param newAdjusterCoefficient The new adjuster coefficient, scaled by 1e18\\n      */\\n    function _setAdjusterCoefficient(uint newAdjusterCoefficient) external {\\n        // Check caller is admin\\n        require(msg.sender == admin, \\\"only the admin may set the adjuster coefficient\\\");\\n        uint oldAdjusterCoefficient = adjusterCoefficient;\\n        adjusterCoefficient = newAdjusterCoefficient;\\n        emit NewAdjusterCoefficient(oldAdjusterCoefficient, adjusterCoefficient);\\n    }\\n\\n    /**\\n      * @notice Sets the update frequency for Note's interest rate\\n      * @dev Admin function to set the update frequency\\n      * @param newUpdateFrequency The new update frequency, scaled by 1e18\\n      */\\n    function _setUpdateFrequency(uint newUpdateFrequency) external {\\n        // Check caller is admin\\n        require(msg.sender == admin, \\\"only the admin may set the update frequency\\\");\\n        uint oldUpdateFrequency = updateFrequency;\\n        updateFrequency = newUpdateFrequency;\\n        emit NewUpdateFrequency(oldUpdateFrequency, updateFrequency);\\n    }\\n}\",\"keccak256\":\"0xd39023bb97578225f8ba76b2987ddfab6629b09533497705c1eaf9f11b9e3b75\"},\"contracts/PriceOracle.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./CToken.sol\\\";\\n\\nabstract contract PriceOracle {\\n    /// @notice Indicator that this is a PriceOracle contract (for inspection)\\n    bool public constant isPriceOracle = true;\\n\\n    /**\\n      * @notice Get the underlying price of a cToken asset\\n      * @param cToken The cToken to get the underlying price of\\n      * @return The underlying asset price mantissa (scaled by 1e18).\\n      *  Zero means the price is unavailable.\\n      */\\n    function getUnderlyingPrice(CToken cToken) virtual external view returns (uint);\\n}\\n\",\"keccak256\":\"0x3bdb44d513360f19ba6e93960fbf37184cd7952492ab0ee4a91f514b3f2ea923\",\"license\":\"BSD-3-Clause\"},\"contracts/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\\n// Subject to the MIT license.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c;\\n        unchecked { c = a + b; }\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        uint256 c;\\n        unchecked { c = a + b; }\\n        require(c >= a, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction underflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c;\\n        unchecked { c = a * b; }\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c;\\n        unchecked { c = a * b; }\\n        require(c / a == b, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xadaf3cd4210722dbf84790bcdbff78389a0a2772b11e75e42a4f2430a6d1e14e\",\"license\":\"BSD-3-Clause\"},\"contracts/SimplePriceOracle.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.10;\\n\\nimport \\\"./PriceOracle.sol\\\";\\nimport \\\"./CErc20.sol\\\";\\n\\ncontract SimplePriceOracle is PriceOracle {\\n    mapping(address => uint) prices;\\n    event PricePosted(address asset, uint previousPriceMantissa, uint requestedPriceMantissa, uint newPriceMantissa);\\n\\n    function _getUnderlyingAddress(CToken cToken) private view returns (address) {\\n        address asset;\\n        if (compareStrings(cToken.symbol(), \\\"cCANTO\\\")) {\\n            asset = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n        } else {\\n            asset = address(CErc20(address(cToken)).underlying());\\n        }\\n        return asset;\\n    }\\n\\n    function getUnderlyingPrice(CToken cToken) public override view returns (uint) {\\n        return prices[_getUnderlyingAddress(cToken)];\\n    }\\n\\n    function setUnderlyingPrice(CToken cToken, uint underlyingPriceMantissa) public {\\n        address asset = _getUnderlyingAddress(cToken);\\n        emit PricePosted(asset, prices[asset], underlyingPriceMantissa, underlyingPriceMantissa);\\n        prices[asset] = underlyingPriceMantissa;\\n    }\\n\\n    function setDirectPrice(address asset, uint price) public {\\n        emit PricePosted(asset, prices[asset], price, price);\\n        prices[asset] = price;\\n    }\\n\\n    // v1 price oracle interface for use as backing of proxy\\n    function assetPrices(address asset) external view returns (uint) {\\n        return prices[asset];\\n    }\\n\\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\\n    }\\n}\\n\",\"keccak256\":\"0xcb7fc6dc927440a9a30137cb8c54b8d2ec7180a3c609b6aa9c06f770d2a95d16\",\"license\":\"BSD-3-Clause\"}},\"version\":1}",
  "bytecode": "0x60806040524360015534801561001457600080fd5b506040516109f53803806109f58339810160408190526100339161012c565b61004d625033408261009d60201b6105101790919060201c565b60038190556040519081527f482980278ae2c1b5635532c44722d084a208f79b8f4212a3fc8e6042901552cb9060200160405180910390a150600080546001600160a01b031916331790556101bc565b60006100e583836040518060400160405280601a81526020017f536166654d6174683a206469766973696f6e206279207a65726f0000000000008152506100ec60201b60201c565b9392505050565b600081836101165760405162461bcd60e51b815260040161010d9190610145565b60405180910390fd5b506000610123848661019a565b95945050505050565b60006020828403121561013e57600080fd5b5051919050565b600060208083528351808285015260005b8181101561017257858101830151858201604001528201610156565b81811115610184576000604083870101525b50601f01601f1916929092016040019392505050565b6000826101b757634e487b7160e01b600052601260045260246000fd5b500490565b61082a806101cb6000396000f3fe608060405234801561001057600080fd5b50600436106100ea5760003560e01c80634930e0381161008c578063a385fb9611610066578063a385fb96146101c1578063b8168816146101cb578063de3f9485146101de578063f14039de146101e757600080fd5b80634930e0381461019c578063673ea086146101af578063a218141b146101b857600080fd5b806326d111f5116100c857806326d111f5146101425780632d349a941461016d578063330283aa14610176578063477caf6b1461018957600080fd5b806315f24053146100ef5780632191f92a1461011557806324d6f3331461012d575b600080fd5b6101026100fd3660046106c5565b6101f0565b6040519081526020015b60405180910390f35b61011d600181565b604051901515815260200161010c565b61014061013b3660046106f1565b61028b565b005b600654610155906001600160a01b031681565b6040516001600160a01b03909116815260200161010c565b61010260045481565b6101406101843660046106f1565b610344565b6101406101973660046106f1565b6103a6565b6101406101aa3660046106f1565b610456565b61010260055481565b61010260015481565b6101026250334081565b6101026101d936600461070a565b6104fa565b61010260025481565b61010260035481565b6040516bffffffffffffffffffffffff193360601b16602082015260009081906064906034016040516020818303038152906040528051906020012060001c6102399190610752565b9050600061026d662386f26fc100006102616002546102676004548760646102619190610766565b9061055b565b906105cf565b905080600061027f8262503340610510565b98975050505050505050565b6000546001600160a01b031633146102fe5760405162461bcd60e51b815260206004820152602b60248201527f6f6e6c79207468652061646d696e206d6179207365742074686520757064617460448201526a65206672657175656e637960a81b60648201526084015b60405180910390fd5b600580549082905560408051828152602081018490527f24eb712b5908e642132e2dd0ee4c85e189162ea03242c80f82d94db64f2ba9d191015b60405180910390a15050565b6001544390600090610357908390610624565b90506005548111156103a157600283905560018290556040518381527f482980278ae2c1b5635532c44722d084a208f79b8f4212a3fc8e6042901552cb9060200160405180910390a15b505050565b6000546001600160a01b031633146104185760405162461bcd60e51b815260206004820152602f60248201527f6f6e6c79207468652061646d696e206d617920736574207468652061646a757360448201526e1d195c8818dbd959999a58da595b9d608a1b60648201526084016102f5565b600480549082905560408051828152602081018490527fae1920adb21e7676257fad295b40649a2bea63dc815e66532950aba41e2d4fee9101610338565b6000546001600160a01b031633146104bc5760405162461bcd60e51b8152602060048201526024808201527f6f6e6c79207468652061646d696e206d617920736574207468652062617365206044820152637261746560e01b60648201526084016102f5565b600280549082905560408051828152602081018490527f725ddbfd43744d5aa9deca7b3f1d89f8d0ab476b969a23d69d083f5b37d994369101610338565b60006105078585856101f0565b95945050505050565b600061055283836040518060400160405280601a81526020017f536166654d6174683a206469766973696f6e206279207a65726f000000000000815250610666565b90505b92915050565b60008261056a57506000610555565b82820282610578858361078b565b146105525760405162461bcd60e51b815260206004820152602160248201527f536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f6044820152607760f81b60648201526084016102f5565b6000828201838110156105525760405162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f77000000000060448201526064016102f5565b600061055283836040518060400160405280601f81526020017f536166654d6174683a207375627472616374696f6e20756e646572666c6f7700815250610694565b600081836106875760405162461bcd60e51b81526004016102f5919061079f565b506000610507848661078b565b600081848411156106b85760405162461bcd60e51b81526004016102f5919061079f565b5060006105078486610766565b6000806000606084860312156106da57600080fd5b505081359360208301359350604090920135919050565b60006020828403121561070357600080fd5b5035919050565b6000806000806080858703121561072057600080fd5b5050823594602084013594506040840135936060013592509050565b634e487b7160e01b600052601260045260246000fd5b6000826107615761076161073c565b500690565b60008282101561078657634e487b7160e01b600052601160045260246000fd5b500390565b60008261079a5761079a61073c565b500490565b600060208083528351808285015260005b818110156107cc578581018301518582016040015282016107b0565b818111156107de576000604083870101525b50601f01601f191692909201604001939250505056fea2646970667358221220d6db2c3d0147d175cd510268c874ac6943a2a2d5901b6adace2a2f14bc6e7f3c64736f6c634300080a0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100ea5760003560e01c80634930e0381161008c578063a385fb9611610066578063a385fb96146101c1578063b8168816146101cb578063de3f9485146101de578063f14039de146101e757600080fd5b80634930e0381461019c578063673ea086146101af578063a218141b146101b857600080fd5b806326d111f5116100c857806326d111f5146101425780632d349a941461016d578063330283aa14610176578063477caf6b1461018957600080fd5b806315f24053146100ef5780632191f92a1461011557806324d6f3331461012d575b600080fd5b6101026100fd3660046106c5565b6101f0565b6040519081526020015b60405180910390f35b61011d600181565b604051901515815260200161010c565b61014061013b3660046106f1565b61028b565b005b600654610155906001600160a01b031681565b6040516001600160a01b03909116815260200161010c565b61010260045481565b6101406101843660046106f1565b610344565b6101406101973660046106f1565b6103a6565b6101406101aa3660046106f1565b610456565b61010260055481565b61010260015481565b6101026250334081565b6101026101d936600461070a565b6104fa565b61010260025481565b61010260035481565b6040516bffffffffffffffffffffffff193360601b16602082015260009081906064906034016040516020818303038152906040528051906020012060001c6102399190610752565b9050600061026d662386f26fc100006102616002546102676004548760646102619190610766565b9061055b565b906105cf565b905080600061027f8262503340610510565b98975050505050505050565b6000546001600160a01b031633146102fe5760405162461bcd60e51b815260206004820152602b60248201527f6f6e6c79207468652061646d696e206d6179207365742074686520757064617460448201526a65206672657175656e637960a81b60648201526084015b60405180910390fd5b600580549082905560408051828152602081018490527f24eb712b5908e642132e2dd0ee4c85e189162ea03242c80f82d94db64f2ba9d191015b60405180910390a15050565b6001544390600090610357908390610624565b90506005548111156103a157600283905560018290556040518381527f482980278ae2c1b5635532c44722d084a208f79b8f4212a3fc8e6042901552cb9060200160405180910390a15b505050565b6000546001600160a01b031633146104185760405162461bcd60e51b815260206004820152602f60248201527f6f6e6c79207468652061646d696e206d617920736574207468652061646a757360448201526e1d195c8818dbd959999a58da595b9d608a1b60648201526084016102f5565b600480549082905560408051828152602081018490527fae1920adb21e7676257fad295b40649a2bea63dc815e66532950aba41e2d4fee9101610338565b6000546001600160a01b031633146104bc5760405162461bcd60e51b8152602060048201526024808201527f6f6e6c79207468652061646d696e206d617920736574207468652062617365206044820152637261746560e01b60648201526084016102f5565b600280549082905560408051828152602081018490527f725ddbfd43744d5aa9deca7b3f1d89f8d0ab476b969a23d69d083f5b37d994369101610338565b60006105078585856101f0565b95945050505050565b600061055283836040518060400160405280601a81526020017f536166654d6174683a206469766973696f6e206279207a65726f000000000000815250610666565b90505b92915050565b60008261056a57506000610555565b82820282610578858361078b565b146105525760405162461bcd60e51b815260206004820152602160248201527f536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f6044820152607760f81b60648201526084016102f5565b6000828201838110156105525760405162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f77000000000060448201526064016102f5565b600061055283836040518060400160405280601f81526020017f536166654d6174683a207375627472616374696f6e20756e646572666c6f7700815250610694565b600081836106875760405162461bcd60e51b81526004016102f5919061079f565b506000610507848661078b565b600081848411156106b85760405162461bcd60e51b81526004016102f5919061079f565b5060006105078486610766565b6000806000606084860312156106da57600080fd5b505081359360208301359350604090920135919050565b60006020828403121561070357600080fd5b5035919050565b6000806000806080858703121561072057600080fd5b5050823594602084013594506040840135936060013592509050565b634e487b7160e01b600052601260045260246000fd5b6000826107615761076161073c565b500690565b60008282101561078657634e487b7160e01b600052601160045260246000fd5b500390565b60008261079a5761079a61073c565b500490565b600060208083528351808285015260005b818110156107cc578581018301518582016040015282016107b0565b818111156107de576000604083870101525b50601f01601f191692909201604001939250505056fea2646970667358221220d6db2c3d0147d175cd510268c874ac6943a2a2d5901b6adace2a2f14bc6e7f3c64736f6c634300080a0033",
  "devdoc": {
    "author": "canto",
    "kind": "dev",
    "methods": {
      "_setAdjusterCoefficient(uint256)": {
        "details": "Admin function to set per-market adjuster coefficient",
        "params": {
          "newAdjusterCoefficient": "The new adjuster coefficient, scaled by 1e18"
        }
      },
      "_setBaseRatePerYear(uint256)": {
        "details": "Admin function to set per-market base interest rate",
        "params": {
          "newBaseRateMantissa": "The new base interest rate, scaled by 1e18"
        }
      },
      "_setUpdateFrequency(uint256)": {
        "details": "Admin function to set the update frequency",
        "params": {
          "newUpdateFrequency": "The new update frequency, scaled by 1e18"
        }
      },
      "constructor": {
        "params": {
          "baseRatePerYear": "The approximate target base APR, as a mantissa (scaled by 1e18), set by admin, default 2%"
        }
      },
      "getBorrowRate(uint256,uint256,uint256)": {
        "returns": {
          "_0": "Note's borrow rate percentage per block as a mantissa (scaled by 1e18)"
        }
      },
      "getSupplyRate(uint256,uint256,uint256,uint256)": {
        "returns": {
          "_0": "Note's supply rate percentage per block as a mantissa (scaled by 1e18)"
        }
      },
      "updateBaseRate(uint256)": {
        "params": {
          "newBaseRatePerYear": "The new base rate per year of Note"
        }
      }
    },
    "title": "note's interest rate model contract",
    "version": 1
  },
  "userdoc": {
    "events": {
      "NewAdjusterCoefficient(uint256,uint256)": {
        "notice": "Emitted when adjuster coefficient is changed by admin"
      },
      "NewBaseRate(uint256,uint256)": {
        "notice": "Emitted when base rate is changed by admin"
      },
      "NewUpdateFrequency(uint256,uint256)": {
        "notice": "Emitted when update frequency is changed by admin"
      }
    },
    "kind": "user",
    "methods": {
      "_setAdjusterCoefficient(uint256)": {
        "notice": "Sets the adjuster coefficient for Note"
      },
      "_setBaseRatePerYear(uint256)": {
        "notice": "Sets the base interest rate for Note"
      },
      "_setUpdateFrequency(uint256)": {
        "notice": "Sets the update frequency for Note's interest rate"
      },
      "adjusterCoefficient()": {
        "notice": "The level of aggressiveness to adjust interest rate according to twap's deviation from the peg"
      },
      "baseRatePerBlock()": {
        "notice": "baseRatePerBlock The per block interest rate, as a mantissa (scaled by 1e18)"
      },
      "baseRatePerYear()": {
        "notice": "baseRatePerYear The per year interest rate, as a mantissa (scaled by 1e18)"
      },
      "blocksPerYear()": {
        "notice": "The approximate number of blocks per year that is assumed by the interest rate model"
      },
      "constructor": {
        "notice": "Construct an interest rate model"
      },
      "getBorrowRate(uint256,uint256,uint256)": {
        "notice": "Calculates the current borrow rate per block, with the error code expected by the marketThe following parameters are irrelevent for calculating Note's interest rate. They are passed in to align with the standard function definition `getBorrowRate` in InterestRateModel"
      },
      "getSupplyRate(uint256,uint256,uint256,uint256)": {
        "notice": "Calculates the current supply rate per block, which is the same as the borrow rateThe following parameters are irrelevent for calculating Note's interest rate. They are passed in to align with the standard function definition `getSupplyRate` in InterestRateModel"
      },
      "isInterestRateModel()": {
        "notice": "Indicator that this is an InterestRateModel contract (for inspection)"
      },
      "lastUpdateBlock()": {
        "notice": "The variable to keep track of the last update on Note's interest rate, initialized at the current block number"
      },
      "note()": {
        "notice": "The CToken identifier for Note"
      },
      "updateBaseRate(uint256)": {
        "notice": "Updates the Note's base rate per year at a given intervalThis function should be called at a given interval (TBD)"
      },
      "updateFrequency()": {
        "notice": "The frequency of updating Note's base rate"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 22712,
        "contract": "contracts/NoteInterest.sol:NoteRateModel",
        "label": "admin",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 22721,
        "contract": "contracts/NoteInterest.sol:NoteRateModel",
        "label": "lastUpdateBlock",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 22724,
        "contract": "contracts/NoteInterest.sol:NoteRateModel",
        "label": "baseRatePerYear",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 22727,
        "contract": "contracts/NoteInterest.sol:NoteRateModel",
        "label": "baseRatePerBlock",
        "offset": 0,
        "slot": "3",
        "type": "t_uint256"
      },
      {
        "astId": 22730,
        "contract": "contracts/NoteInterest.sol:NoteRateModel",
        "label": "adjusterCoefficient",
        "offset": 0,
        "slot": "4",
        "type": "t_uint256"
      },
      {
        "astId": 22733,
        "contract": "contracts/NoteInterest.sol:NoteRateModel",
        "label": "updateFrequency",
        "offset": 0,
        "slot": "5",
        "type": "t_uint256"
      },
      {
        "astId": 22737,
        "contract": "contracts/NoteInterest.sol:NoteRateModel",
        "label": "note",
        "offset": 0,
        "slot": "6",
        "type": "t_contract(CToken)6352"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_contract(CToken)6352": {
        "encoding": "inplace",
        "label": "contract CToken",
        "numberOfBytes": "20"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}